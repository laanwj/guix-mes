;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; base-0.mes is the first file being loaded from the Mes core.  It
;;; provides primitives that use Mes internals to create the illusion
;;; of compatibility with Guile.  It is not safe to be run by Guile.

;;; Code:

(define (effective-version) %version)
(define mes? #t)
(define guile? #f)
(define guile-1.8? #f)
(define guile-2? #f)

(define (primitive-eval e) (core:eval e (current-module)))
(define eval core:eval)

(define-macro (defined? x)
  (list 'assq x '(cdr (cdr (current-module)))))

(if (defined? 'current-input-port) #t
    (define (current-input-port) 0))

(define (current-output-port) 1)
(define (current-error-port) 2)
(define (port-filename port) "<stdin>")
(define (port-line port) 0)
(define (port-column port) 0)
(define (ftell port) 0)
(define (false-if-exception x) x)

(define (cons* . rest)
  (if (null? (cdr rest)) (car rest)
      (cons (car rest) (core:apply cons* (cdr rest) (current-module)))))

(define (apply f h . t)
  (if (null? t) (core:apply f h (current-module))
      (apply f (apply cons* (cons h t)))))

(define-macro (cond . clauses)
  (list 'if (pair? clauses)
        (list (cons
               'lambda
               (cons
                '(test)
                (list (list 'if 'test
                            (if (pair? (cdr (car clauses)))
                                (if (eq? (car (cdr (car clauses))) '=>)
                                    (append2 (cdr (cdr (car clauses))) '(test))
                                    (list (cons 'lambda (cons '() (car clauses)))))
                                (list (cons 'lambda (cons '() (car clauses)))))
                            (if (pair? (cdr clauses))
                                (cons 'cond (cdr clauses)))))))
              (car (car clauses)))))

(define else #t)

(define (cadr x) (car (cdr x)))
(define-macro (simple-let bindings . rest)
  (cons (cons 'lambda (cons (map1 car bindings) rest))
        (map1 cadr bindings)))

(define-macro (let bindings . rest)
  (cons 'simple-let (cons bindings rest)))

(define *input-ports* '())
(define-macro (push! stack o)
  (cons
   'begin
   (list
    (list 'set! stack (list cons o stack))
    stack)))
(define-macro (pop! stack)
  (list 'let (list (list 'o (list car stack)))
        (list 'set! stack (list cdr stack))
        'o))
(define-macro (load file)
  (list 'begin
        (list 'if (list getenv "MES_DEBUG")
              (list 'begin
                    (list core:display-error "read ")
                    (list core:display-error file)
                    (list core:display-error "\n")))
     (list 'push! '*input-ports* (list current-input-port))
     (list 'set-current-input-port (list open-input-file file))
     (list 'primitive-load)
     (list 'set-current-input-port (list 'pop! '*input-ports*))))

(define include load)
(define-macro (include-from-path file)
  (list 'load (list string-append "module/" file)))

(define (append . rest)
  (if (null? rest) '()
      (if (null? (cdr rest)) (car rest)
          (append2 (car rest) (apply append (cdr rest))))))

(include "module/mes/type-0.mes")

(define (memq x lst)
  (if (null? lst) #f
      (if (eq? x (car lst)) lst
          (memq x (cdr lst)))))

(define (string-join lst infix)
  (if (null? (cdr lst)) (car lst)
      (string-append (car lst) infix (string-join (cdr lst) infix))))

(define *mes-prefix* "module/")
(define (module->file o)
  (string-append (string-join (map1 symbol->string o) "/") ".mes"))

(define *modules* '(mes/base-0.mes))
(define (mes-load-module-env module a)
  (push! *input-ports* (current-input-port))
  (set-current-input-port (open-input-file (string-append *mes-prefix* (module->file module))))
  (let ((x (core:eval (append2 (cons 'begin (read-input-file-env a))
                               '((current-module)))
                      a)))
    (set-current-input-port (pop! *input-ports*))
    x))
(define (not x)
  (if x #f #t))
(define-macro (mes-use-module module)
  (list
   'begin
   (list 'if (list 'not (list 'memq (list string->symbol (module->file module)) '*modules*))
         (list
          'begin
          (list 'set! '*modules* (list cons (list string->symbol (module->file module)) '*modules*))
          (list 'load (list string-append '*mes-prefix* (module->file module)))))))

(mes-use-module (mes base))
(mes-use-module (srfi srfi-0))
(mes-use-module (mes quasiquote))
(mes-use-module (mes let))
(mes-use-module (mes scm))
(mes-use-module (srfi srfi-13))
(mes-use-module (mes display))
(mes-use-module (mes catch))
